{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar named_references_1 = require(\"./named-references\");\nvar numeric_unicode_map_1 = require(\"./numeric-unicode-map\");\nvar surrogate_pairs_1 = require(\"./surrogate-pairs\");\nvar allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), {\n  all: named_references_1.namedReferences.html5\n});\nfunction replaceUsingRegExp(macroText, macroRegExp, macroReplacer) {\n  macroRegExp.lastIndex = 0;\n  var replaceMatch = macroRegExp.exec(macroText);\n  var replaceResult;\n  if (replaceMatch) {\n    replaceResult = \"\";\n    var replaceLastIndex = 0;\n    do {\n      if (replaceLastIndex !== replaceMatch.index) {\n        replaceResult += macroText.substring(replaceLastIndex, replaceMatch.index);\n      }\n      var replaceInput = replaceMatch[0];\n      replaceResult += macroReplacer(replaceInput);\n      replaceLastIndex = replaceMatch.index + replaceInput.length;\n    } while (replaceMatch = macroRegExp.exec(macroText));\n    if (replaceLastIndex !== macroText.length) {\n      replaceResult += macroText.substring(replaceLastIndex);\n    }\n  } else {\n    replaceResult = macroText;\n  }\n  return replaceResult;\n}\nvar encodeRegExps = {\n  specialChars: /[<>'\"&]/g,\n  nonAscii: /[<>'\"&\\u0080-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  nonAsciiPrintable: /[<>'\"&\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  nonAsciiPrintableOnly: /[\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n  extensive: /[\\x01-\\x0c\\x0e-\\x1f\\x21-\\x2c\\x2e-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7d\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g\n};\nvar defaultEncodeOptions = {\n  mode: \"specialChars\",\n  level: \"all\",\n  numeric: \"decimal\"\n};\nfunction encode(text, _a) {\n  var _b = _a === void 0 ? defaultEncodeOptions : _a,\n    _c = _b.mode,\n    mode = _c === void 0 ? \"specialChars\" : _c,\n    _d = _b.numeric,\n    numeric = _d === void 0 ? \"decimal\" : _d,\n    _e = _b.level,\n    level = _e === void 0 ? \"all\" : _e;\n  if (!text) {\n    return \"\";\n  }\n  var encodeRegExp = encodeRegExps[mode];\n  var references = allNamedReferences[level].characters;\n  var isHex = numeric === \"hexadecimal\";\n  return replaceUsingRegExp(text, encodeRegExp, function (input) {\n    var result = references[input];\n    if (!result) {\n      var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);\n      result = (isHex ? \"&#x\" + code.toString(16) : \"&#\" + code) + \";\";\n    }\n    return result;\n  });\n}\nexports.encode = encode;\nvar defaultDecodeOptions = {\n  scope: \"body\",\n  level: \"all\"\n};\nvar strict = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);/g;\nvar attribute = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;\nvar baseDecodeRegExps = {\n  xml: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.xml\n  },\n  html4: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.html4\n  },\n  html5: {\n    strict: strict,\n    attribute: attribute,\n    body: named_references_1.bodyRegExps.html5\n  }\n};\nvar decodeRegExps = __assign(__assign({}, baseDecodeRegExps), {\n  all: baseDecodeRegExps.html5\n});\nvar fromCharCode = String.fromCharCode;\nvar outOfBoundsChar = fromCharCode(65533);\nvar defaultDecodeEntityOptions = {\n  level: \"all\"\n};\nfunction getDecodedEntity(entity, references, isAttribute, isStrict) {\n  var decodeResult = entity;\n  var decodeEntityLastChar = entity[entity.length - 1];\n  if (isAttribute && decodeEntityLastChar === \"=\") {\n    decodeResult = entity;\n  } else if (isStrict && decodeEntityLastChar !== \";\") {\n    decodeResult = entity;\n  } else {\n    var decodeResultByReference = references[entity];\n    if (decodeResultByReference) {\n      decodeResult = decodeResultByReference;\n    } else if (entity[0] === \"&\" && entity[1] === \"#\") {\n      var decodeSecondChar = entity[2];\n      var decodeCode = decodeSecondChar == \"x\" || decodeSecondChar == \"X\" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));\n      decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);\n    }\n  }\n  return decodeResult;\n}\nfunction decodeEntity(entity, _a) {\n  var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level,\n    level = _b === void 0 ? \"all\" : _b;\n  if (!entity) {\n    return \"\";\n  }\n  return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);\n}\nexports.decodeEntity = decodeEntity;\nfunction decode(text, _a) {\n  var _b = _a === void 0 ? defaultDecodeOptions : _a,\n    _c = _b.level,\n    level = _c === void 0 ? \"all\" : _c,\n    _d = _b.scope,\n    scope = _d === void 0 ? level === \"xml\" ? \"strict\" : \"body\" : _d;\n  if (!text) {\n    return \"\";\n  }\n  var decodeRegExp = decodeRegExps[level][scope];\n  var references = allNamedReferences[level].entities;\n  var isAttribute = scope === \"attribute\";\n  var isStrict = scope === \"strict\";\n  return replaceUsingRegExp(text, decodeRegExp, function (entity) {\n    return getDecodedEntity(entity, references, isAttribute, isStrict);\n  });\n}\nexports.decode = decode;","map":{"version":3,"sources":["C:\\Users\\sujit\\OneDrive\\Desktop\\CodePeers\\client\\node_modules\\html-entities\\src\\index.ts"],"names":["allNamedReferences","__assign","named_references_1","all","html5","replaceUsingRegExp","macroText","macroRegExp","macroReplacer","lastIndex","replaceMatch","exec","replaceResult","replaceLastIndex","index","substring","replaceInput","length","encodeRegExps","specialChars","nonAscii","nonAsciiPrintable","nonAsciiPrintableOnly","extensive","defaultEncodeOptions","mode","level","numeric","encode","text","_a","_c","_d","_e","encodeRegExp","references","characters","isHex","input","result","code","surrogate_pairs_1","charCodeAt","toString","defaultDecodeOptions","scope","strict","attribute","baseDecodeRegExps","xml","body","html4","decodeRegExps","fromCharCode","String","outOfBoundsChar","defaultDecodeEntityOptions","getDecodedEntity","entity","isAttribute","isStrict","decodeResult","decodeEntityLastChar","decodeResultByReference","decodeSecondChar","decodeCode","parseInt","substr","numeric_unicode_map_1","decodeEntity","_b","entities","decode","decodeRegExp"],"mappings":"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","sourcesContent":["import {bodyRegExps, namedReferences} from './named-references';\nimport {numericUnicodeMap} from './numeric-unicode-map';\nimport {fromCodePoint, getCodePoint} from './surrogate-pairs';\n\nconst allNamedReferences = {\n    ...namedReferences,\n    all: namedReferences.html5\n};\n\nfunction replaceUsingRegExp(macroText: string, macroRegExp: RegExp, macroReplacer: (input: string) => string): string {\n    macroRegExp.lastIndex = 0;\n    let replaceMatch = macroRegExp.exec(macroText);\n    let replaceResult;\n    if (replaceMatch) {\n        replaceResult = '';\n        let replaceLastIndex = 0;\n        do {\n            if (replaceLastIndex !== replaceMatch.index) {\n                replaceResult += macroText.substring(replaceLastIndex, replaceMatch.index);\n            }\n            const replaceInput = replaceMatch[0];\n            replaceResult += macroReplacer(replaceInput);\n            replaceLastIndex = replaceMatch.index + replaceInput.length;\n        } while ((replaceMatch = macroRegExp.exec(macroText)));\n\n        if (replaceLastIndex !== macroText.length) {\n            replaceResult += macroText.substring(replaceLastIndex);\n        }\n    } else {\n        replaceResult = macroText;\n    }\n    return replaceResult;\n}\n\nexport type Level = 'xml' | 'html4' | 'html5' | 'all';\n\ninterface CommonOptions {\n    level?: Level;\n}\n\nexport type EncodeMode = 'specialChars' | 'nonAscii' | 'nonAsciiPrintable' | 'nonAsciiPrintableOnly' | 'extensive';\n\nexport interface EncodeOptions extends CommonOptions {\n    mode?: EncodeMode;\n    numeric?: 'decimal' | 'hexadecimal';\n}\n\nexport type DecodeScope = 'strict' | 'body' | 'attribute';\n\nexport interface DecodeOptions extends CommonOptions {\n    scope?: DecodeScope;\n}\n\nconst encodeRegExps: Record<EncodeMode, RegExp> = {\n    specialChars: /[<>'\"&]/g,\n    nonAscii: /[<>'\"&\\u0080-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n    nonAsciiPrintable: /[<>'\"&\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n    nonAsciiPrintableOnly: /[\\x01-\\x08\\x11-\\x15\\x17-\\x1F\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g,\n    extensive: /[\\x01-\\x0c\\x0e-\\x1f\\x21-\\x2c\\x2e-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7d\\x7f-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/g\n};\n\nconst defaultEncodeOptions: EncodeOptions = {\n    mode: 'specialChars',\n    level: 'all',\n    numeric: 'decimal'\n};\n\n/** Encodes all the necessary (specified by `level`) characters in the text */\nexport function encode(\n    text: string | undefined | null,\n    {mode = 'specialChars', numeric = 'decimal', level = 'all'}: EncodeOptions = defaultEncodeOptions\n) {\n    if (!text) {\n        return '';\n    }\n\n    const encodeRegExp = encodeRegExps[mode];\n    const references = allNamedReferences[level].characters;\n    const isHex = numeric === 'hexadecimal';\n\n    return replaceUsingRegExp(text, encodeRegExp, (input) => {\n        let result = references[input];\n        if (!result) {\n            const code = input.length > 1 ? getCodePoint(input, 0)! : input.charCodeAt(0);\n            result = (isHex ? '&#x' + code.toString(16) : '&#' + code) + ';';\n        }\n        return result;\n    });\n}\n\nconst defaultDecodeOptions: DecodeOptions = {\n    scope: 'body',\n    level: 'all'\n};\n\nconst strict = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+);/g;\nconst attribute = /&(?:#\\d+|#[xX][\\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;\n\nconst baseDecodeRegExps: Record<Exclude<Level, 'all'>, Record<DecodeScope, RegExp>> = {\n    xml: {\n        strict,\n        attribute,\n        body: bodyRegExps.xml\n    },\n    html4: {\n        strict,\n        attribute,\n        body: bodyRegExps.html4\n    },\n    html5: {\n        strict,\n        attribute,\n        body: bodyRegExps.html5\n    }\n};\n\nconst decodeRegExps: Record<Level, Record<DecodeScope, RegExp>> = {\n    ...baseDecodeRegExps,\n    all: baseDecodeRegExps.html5\n};\n\nconst fromCharCode = String.fromCharCode;\nconst outOfBoundsChar = fromCharCode(65533);\n\nconst defaultDecodeEntityOptions: CommonOptions = {\n    level: 'all'\n};\n\nfunction getDecodedEntity(\n    entity: string,\n    references: Record<string, string>,\n    isAttribute: boolean,\n    isStrict: boolean\n): string {\n    let decodeResult = entity;\n    const decodeEntityLastChar = entity[entity.length - 1];\n    if (isAttribute && decodeEntityLastChar === '=') {\n        decodeResult = entity;\n    } else if (isStrict && decodeEntityLastChar !== ';') {\n        decodeResult = entity;\n    } else {\n        const decodeResultByReference = references[entity];\n        if (decodeResultByReference) {\n            decodeResult = decodeResultByReference;\n        } else if (entity[0] === '&' && entity[1] === '#') {\n            const decodeSecondChar = entity[2];\n            const decodeCode =\n                decodeSecondChar == 'x' || decodeSecondChar == 'X'\n                    ? parseInt(entity.substr(3), 16)\n                    : parseInt(entity.substr(2));\n\n            decodeResult =\n                decodeCode >= 0x10ffff\n                    ? outOfBoundsChar\n                    : decodeCode > 65535\n                    ? fromCodePoint(decodeCode)\n                    : fromCharCode(numericUnicodeMap[decodeCode] || decodeCode);\n        }\n    }\n    return decodeResult;\n}\n\n/** Decodes a single entity */\nexport function decodeEntity(\n    entity: string | undefined | null,\n    {level = 'all'}: CommonOptions = defaultDecodeEntityOptions\n): string {\n    if (!entity) {\n        return '';\n    }\n    return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);\n}\n\n/** Decodes all entities in the text */\nexport function decode(\n    text: string | undefined | null,\n    {level = 'all', scope = level === 'xml' ? 'strict' : 'body'}: DecodeOptions = defaultDecodeOptions\n) {\n    if (!text) {\n        return '';\n    }\n\n    const decodeRegExp = decodeRegExps[level][scope];\n    const references = allNamedReferences[level].entities;\n    const isAttribute = scope === 'attribute';\n    const isStrict = scope === 'strict';\n\n    return replaceUsingRegExp(text, decodeRegExp, (entity) =>\n        getDecodedEntity(entity, references, isAttribute, isStrict)\n    );\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}